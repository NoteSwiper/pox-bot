from collections import Counter, defaultdict
import random
import time
from discord import Locale, app_commands
from discord.app_commands import locale_str

import data

class MyTranslator(app_commands.Translator):
    async def translate(self, string: locale_str, locale: Locale, context: app_commands.TranslationContext):
        translations = {
            'You do not have permission to use commands.': {
                'es-ES': 'No tienes permiso para usar comandos.',
                
            }
        }
        return translations.get(string.message, {}).get(locale.value, string.message)

class Cache:
    def __init__(self, ttl):
        self.ttl = ttl
        self.cache = {}
    
    def set(self, key, value, priority: int = 0):
        self.cache[key] = {'value': value, 'time': time.time(), 'priority': priority}
    
    def get(self, key):
        if key in self.cache:
            entry = self.cache[key]
            if time.time() - entry['time'] < self.ttl:
                return entry['value']
            else:
                del self.cache[key]
        return None
    
    def get_cached_time_by_key(self, key):
        if key in self.cache:
            entry = self.cache[key]
            if time.time() - entry['time'] < self.ttl:
                return entry['time']
            else:
                del self.cache[key]
        return None
    
    def get_priority_by_key(self, key):
        if key in self.cache:
            entry = self.cache[key]
            if time.time() - entry['time'] < self.ttl:
                return entry['priority']
            else:
                del self.cache[key]
        return -1
    
    def get_all(self):
        return self.cache
    
    def get_count(self):
        return len(self.cache)
    
    def get_front(self):
        return self.cache[0] if len(self.cache) > 0 else None
    
    def get_rear(self):
        return self.cache[len(self.cache)-1] if len(self.cache) > 0 else None

class EmoticonGenerator:
    START_CHAR = '^'
    END_CHAR = '$'

    CORPUS = data.emoticons

    def __init__(self, corpus=None):
        self.corpus = corpus if corpus is not None else self.CORPUS
        self.model = self._build_model(self.corpus)
    
    def _build_model(self, corpus):
        model = defaultdict(Counter)

        for emoticon in corpus:
            current_state = self.START_CHAR

            for next_char in emoticon:
                model[current_state][next_char] += 1
                current_state = next_char
            
            model[current_state][self.END_CHAR] += 1
        
        return model
    
    def generate(self, max_length=8):
        current_char = self.START_CHAR
        new_emoticon = []

        for _ in range(max_length):
            if current_char not in self.model: break

            transitions = self.model[current_char]
            next_chars = list(transitions.keys())
            weights = list(transitions.values())

            next_char = random.choices(next_chars, weights=weights, k=1)[0]

            if next_char == self.END_CHAR: break

            new_emoticon.append(next_char)
            current_char = next_char
        
        return "".join(new_emoticon)
